{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// const { parseString } = require('xml2js')\nconst { Base64 } = require('js-base64')\nconst parser = require('fast-xml-parser')\n\nfunction parsePath(key,pic){\n  if(pic.indexOf('/')===0){\n      return pic\n  }else{\n      let idx = key.lastIndexOf('/')\n      if(idx===-1){\n          return pic\n      }else{\n          return key.slice(0,idx+1)+pic\n      }\n  }\n}\n\nconst ActionType = {\n  DetectLabel:'DetectLabel',\n  DetectType:'DetectType',\n  WaterMark:'WaterMark',\n  ImageProcess:'ImageProcess'\n}\n\nasync function callFunction(tcb,options){\n  let ciRes\n  try{\n    ciRes = await tcb.callFunction(options)\n  }catch(err){\n    throw new Error(`[@cloudbase/extension-ci] 调用扩展函数失败 ;  ${err.code} ${err.message}`)\n  }\n  if(ciRes.code){\n    throw new Error(`[@cloudbase/extension-ci] 调用扩展函数失败 ; requestId : ${ciRes.requestId} ; ${ciRes.code} ; ${ciRes.message}`)\n  }\n  const { code } = ciRes.result || {}\n  if(code){\n    throw new Error(`[@cloudbase/extension-ci] ${code} ; requestId : ${ciRes.requestId} ;`)\n  }\n  return ciRes.result\n}\n\nasync function invoke(opts, tcb){\n    \n    let {cloudPath,fileContent,action,operations} = opts\n    if(!action || !ActionType[action]){\n      throw new Error('[@cloudbase/extension-ci] action必须为正确的值')\n    }\n\n    cloudPath = cloudPath.indexOf('/')===0 ? cloudPath.slice(1) : cloudPath\n\n    let headers = {}\n    \n\n\n    let method\n    if(fileContent){\n      if(!(fileContent instanceof Uint8Array)){\n        throw new Error('[@cloudbase/extension-ci] fileContent一定要是Uint8Array对象')\n      }\n    }\n\n    let query\n    if(action === ActionType.DetectLabel){\n      method = 'GET'\n      query = {\n        'ci-process':'detect-label'\n      }\n    } else if (action === ActionType.DetectType){\n      method = 'GET'\n      if(!operations.type){\n        throw new Error('[@cloudbase/extension-ci] DetectType是，type字段不为空')\n      }\n      query = {\n        'ci-process':'sensitive-content-recognition',\n        'detect-type':operations.type\n      }\n      delete operations.type\n    } else if(action === ActionType.ImageProcess){\n      query = 'image_process'\n      method = 'POST'\n    } else if (action === ActionType.WaterMark){\n      method = fileContent ? 'PUT' : 'POST'\n      if(method==='POST'){\n        query = 'image_process'\n      }\n      operations.rules.some(rule=>{\n        if(typeof rule !== 'object'){\n          throw new Error('[@cloudbase/extension-ci] WaterMark,rule必须为对象')\n        }\n      })\n      // let waterMarkImages = operations.rules.map(processRule=>{\n      //   let rule = processRule.rule\n      //   if((rule.type===1 || rule.type === 2) && rule.image){\n      //     if(rule.image.indexOf('/')===0){\n      //       rule.image = rule.image.slice(1)\n      //     }\n      //     return rule.image\n      //   }\n      //   return null\n      // }).filter(image=>!!image)\n\n      for(let processRule of operations.rules){\n        let rule = processRule.rule\n        if( (rule.type === 1 || rule.type === 2) && rule.image){\n          if(rule.image.indexOf('/')===0){\n            rule.image = rule.image.slice(1)\n          }\n          processRule.rule = `watermark/${rule.mode}/type/${rule.type}/image/${rule.image}`\n        }else if(rule.type=== 3 && rule.text){\n          processRule.rule = `watermark/${rule.mode}/type/${rule.type}/text/${Base64.encode(rule.text).replace(/\\//g,'_').replace(/=/g,'').replace(/\\+/g,'-')}`\n        }else{\n          throw new Error('[@cloudbase/extension-ci] WaterMark,rule参数错误')\n        }\n      }\n    }\n\n    if(operations){\n      headers['Pic-Operations'] = JSON.stringify(operations)\n    }\n\n    let functionOpts = {\n      name:'tcb_extension_ci',\n      data:{\n        key: cloudPath,\n        action,\n        query : typeof query === 'object' ? query : null,\n        headers,\n        method\n      }\n    }\n\n    let ciRes = await callFunction(tcb, functionOpts)\n\n    const {  authorization, token, url, headers:headerRes } = ciRes || {}\n\n    let options\n    if(method === 'PUT'){\n      const metaDataRes = await tcb.getUploadMetadata({cloudPath})\n      const { data: { cosFileId } } = metaDataRes\n      options = {\n          url,\n          headers:Object.assign({},headerRes,{\n            'x-cos-security-token': token,\n            'x-cos-meta-fileid': cosFileId,\n            Authorization:authorization\n          }),\n          method,\n          body:fileContent\n      }\n    } else {\n\n        let cosFileId\n        if(method === 'POST'){\n          let fileIds = operations.rules.map(rule=>rule.fileid).filter(fileid=>!!fileid)\n          if(fileIds && fileIds.length>0){\n            let filePath = parsePath(cloudPath,fileIds[0])\n            filePath = filePath.indexOf('/')===0 ? filePath.slice(1) : filePath\n            const metaDataRes = await tcb.getUploadMetadata({cloudPath:filePath})\n            cosFileId = metaDataRes.data.cosFileId\n          }\n        }\n\n        let newUrl\n        let queryStr\n        if(query && typeof query === 'object'){\n            queryStr = Object.keys(query).map(key=> key+'='+query[key]).join('&')\n        }else if(query && typeof query === 'string'){\n            queryStr = query\n        }\n\n        newUrl = url\n\n        if(url.indexOf('?')>-1){\n            newUrl += '&'+queryStr\n        }else{\n            newUrl += '?'+queryStr\n        }\n\n        options = {\n            url:newUrl,\n            headers:Object.assign({},headerRes,{\n              Authorization:authorization,\n              'x-cos-security-token': token,\n            }),\n            method:method.toUpperCase(),\n        }\n        if(method==='POST' && cosFileId){\n          options.headers['x-cos-meta-fileid'] = cosFileId\n        }\n    }\n\n    let body = await tcb.requestClient[method.toLowerCase()](options)\n    if(body && body.data){\n      let parseRes = parser.parse(body.data)\n      if(parseRes && parseRes.UploadResult && parseRes.UploadResult.OriginalInfo && parseRes.UploadResult.OriginalInfo.Location){\n        parseRes.UploadResult.OriginalInfo.Location = parseRes.UploadResult.OriginalInfo.Location.replace(/cos\\.ap\\-([a-z]+)\\.myqcloud\\.com/,'tcb.qcloud.la')\n      }\n      if(parseRes && parseRes.UploadResult && parseRes.UploadResult.ProcessResults &&\n        parseRes.UploadResult.ProcessResults.Object && parseRes.UploadResult.ProcessResults.Object.Location\n      ){\n        parseRes.UploadResult.ProcessResults.Object.Location = parseRes.UploadResult.ProcessResults.Object.Location.replace(/cos\\.ap\\-([a-z]+)\\.myqcloud\\.com/,'tcb.qcloud.la')\n      }\n      body.data = parseRes\n    }\n\n    return body\n}\n\nmodule.exports = {\n    name:'CloudInfinite',\n    invoke\n}"]}